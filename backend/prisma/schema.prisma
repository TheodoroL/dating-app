// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite" // ou "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String          @id @default(uuid())
  firstname      String
  lastname       String
  email          String          @unique
  password       String
  gender         Gender
  preference   Gender
  dob        DateTime
  photos         Photo[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

model Photo {
  id        Int      @id @default(autoincrement())
  url       String
  userId    String
  profilePhoto Boolean  @default(false)
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
}

// Tabela de likes: registra quando um usuário curte outro
// Se user A curte user B → cria registro (fromUserId: A, toUserId: B, isLike: true)
// Se user A descurte user B → cria registro (fromUserId: A, toUserId: B, isLike: false)
// Se user B também curte user A → cria registro (fromUserId: B, toUserId: A, isLike: true)
// Quando ambos os registros existem com isLike=true = MATCH automático!
model Like {
  id         Int      @id @default(autoincrement())
  fromUserId String   // Quem deu o like/dislike (você)
  toUserId   String   // Quem recebeu o like/dislike (pessoa que você curtiu/descurtiu)
  isLike     Boolean  @default(true) // true = like, false = dislike
  createdAt  DateTime @default(now())

  @@unique([fromUserId, toUserId]) // Evita que você curta/descurta a mesma pessoa 2x
  @@index([toUserId]) // Otimiza busca de "quem me curtiu"
  @@index([fromUserId, isLike]) // Otimiza busca de descoberta (excluir já vistos)
}

// Match: criado quando dois usuários deram like um no outro
// Permite que eles conversem através de mensagens
model Match {
  id        Int       @id @default(autoincrement())
  user1Id   String    // ID do primeiro usuário
  user2Id   String    // ID do segundo usuário
  createdAt DateTime  @default(now())
  messages  Message[] // Mensagens trocadas neste match

  @@unique([user1Id, user2Id]) // Evita matches duplicados
  @@index([user1Id])
  @@index([user2Id])
}

// Mensagens trocadas dentro de um match
model Message {
  id        Int      @id @default(autoincrement())
  senderId  String   // ID de quem enviou a mensagem
  matchId   Int      // ID do match onde a mensagem foi enviada
  content   String   // Conteúdo da mensagem
  createdAt DateTime @default(now())
  match     Match    @relation(fields: [matchId], references: [id])

  @@index([matchId])
  @@index([senderId])
}

enum Gender {
  MALE
  FEMALE
  OTHER
}
